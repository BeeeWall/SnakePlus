<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta charset="utf-8" />
	<title>Snake+</title>
	<style type="text/css">
		/*<![CDATA[*/
		
		article,
		aside,
		details,
		figcaption,
		figure,
		footer,
		header,
		hgroup,
		menu,
		nav,
		section {
			display: block;
		}
		h1 {
			text-align: left;
		}
		p {
			text-align: left;
		}
		canvas {
			display: block;
			margin: 0 auto;
			top: 5px;
			right: 100px;
			position: fixed;
			background-color: #666;
		}
		/*]]>*/

	</style>
</head>

<body>
	<a href="https://gihub.com/PorygonZRocks/playerPlus" class="github-corner" aria-label="View source on Github">
		<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
			<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
			<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
			<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
		</svg>
	</a>
	<style>
		.github-corner:hover .octo-arm {
			animation: octocat-wave 560ms ease-in-out
		}
		@keyframes octocat-wave {
			0%, 100% {
				transform: rotate(0)
			}
			20%,
			60% {
				transform: rotate(-25deg)
			}
			40%,
			80% {
				transform: rotate(10deg)
			}
		}
		@media (max-width: 500px) {
			.github-corner:hover .octo-arm {
				animation: none
			}
			.github-corner .octo-arm {
				animation: octocat-wave 560ms ease-in-out
			}
		}

	</style>
	<h1>Snake+</h1>
	<p><a href="http://en.wikipedia.org/wiki/HTML5">HTML5</a> variation of the classic <a href="http://en.wikipedia.org/wiki/player_(video_game)">player game</a>.</p>

	<p>Control player with arrow keys, WASD, or HJKL (vim keys).</p>

	<p>Collect the food to grow and increase speed.</p>
	<div>
		<canvas id="the-game" width="320" height="240"></canvas>
	</div>
	<p>&#169; 2013 <a href="http://JDStraughan.com">Jason D. Straughan</a> - <a href="https://github.com/JDStraughan/html5-player">Source on GitHub</a>
	</p>
	<script type="text/javascript">
		/*<![CDATA[*/
		/* jshint -W079 */
		/* set up of game canvas' along with the expected game style (2D) and resisze canvas to fit screen
		   game: game state holder
		   player: player character to be moved by user
		   food: objects to be collected by player character */
		var canvas = document.getElementById("the-game");
		var context = canvas.getContext("2d");
		context.canvas.height = Math.floor(window.innerHeight / 15) * 15;
		context.canvas.width = Math.floor(context.canvas.height * (4 / 3));
		var game, player, ai, food1, food2;
		/* game properties */
		game = {
			/* set up of starting game state
			   variables are initialized to represent a new game */
			score: 0,
			fps: 8,
			over: false,
			message: null,
			/* variables are adjusted to represent the beginnning of a new game */
			start: function () { /* starting a new game */
				game.over = false; /* game state has been changed to in progress */
				game.message = null; /* no message displayed to user */
				game.score = 0;
				game.fps = 8;
				snakeInit(player);
				snakeInit(ai);
				foodSet(1);
				foodSet(2);
				foodSet(3);
			},
			/* variables are adjusted to represent the end of a game */
			stop: function () { /* stopping a game */
				game.over = true; /* game state has been changed to over */
				game.message = 'GAME OVER - PRESS SPACEBAR'; /* message displayed to user notifying game has ended */
			},
			/* x: initial game board center represented by an x-coordinate
			   y: initial game board center represented by a y-coordinate
			   size: maximum size of the board in the x or y direction, used for both coordinates to create a square
			   color: fill color of the game board */
			drawBox: function (x, y, size, color) {
				context.fillStyle = color;
				context.beginPath();
				context.moveTo(x - (size / 2), y - (size / 2)); /* begins fill path at bottom left from centre point */
				context.lineTo(x + (size / 2), y - (size / 2)); /* line from bottom left to bottom right */
				context.lineTo(x + (size / 2), y + (size / 2)); /* line from bottom right to top right */
				context.lineTo(x - (size / 2), y + (size / 2)); /* line from top right to top left */
				context.closePath(); /* paths created are closed off */
				context.fill(); /* area created by these lines are now filled with a solid color */
			},
			/* creates textfield for the scoreboard
			   fill color of scoreboard and font of scoreboard are chosen
			   scoreboard text is aligned
			   scoreboard textfield filled with score and textfield dimensions are set */
			drawScore: function () {
				context.fillStyle = '#999';
				context.font = (canvas.height) + 'px Impact, sans-serif';
				context.textAlign = 'center';
				context.fillText(game.score, canvas.width / 2, canvas.height * 0.9);
			},
			/* creates textfield for the display messages
			   fill color of display message and font of display message are chosen
			   display message text is aligned
			   display message textfield filled with messages and textfield dimensions are set */
			drawMessage: function () {
				if (game.message !== null) {
					context.fillStyle = '#00F';
					context.strokeStyle = '#FFF';
					context.font = (canvas.height / 10) + 'px Impact';
					context.textAlign = 'center';
					context.fillText(game.message, canvas.width / 2, canvas.height / 2);
					context.strokeText(game.message, canvas.width / 2, canvas.height / 2);
				}
			},
			/* resets the gameboard */
			resetCanvas: function () {
				context.clearRect(0, 0, canvas.width, canvas.height);
			}
		};
		/* player properties */
		player = {
			/* variables are initialized to represent a new player */
			size: canvas.width / 40,
			color: '#0F0',
			direction: 'left',
			sections: [],
			/* section: an individual section of the player */
			drawSection: function (section) {
				game.drawBox(parseInt(section[0]), parseInt(section[1]), player.size, player.color); /* player sections are drawn individially inside the box */
			},
			/* collision detection */
			checkCollision: function () {
				if (snakeIsCollision(player, player.x, player.y) === true) { /* if the head of the player collides with something */
					game.stop(); /* game state is changed to over */
				}
			},
		};
		/* ai properties */
		ai = {
			/* variables are initialized to represent a new player */
			size: canvas.width / 40,
			color: '#F0F',
			direction: 'left',
			sections: [],
			/* section: an individual section of the player */
			drawSection: function (section) {
				game.drawBox(parseInt(section[0]), parseInt(section[1]), ai.size, ai.color); /* player sections are drawn individially inside the box */
			},
			/* collision detection */
			checkCollision: function () {
				if (snakeIsCollision(ai, ai.x, ai.y) === true) { /* if the head of the player collides with something */
					game.stop(); /* game state is changed to over */
				}
			},
		};
		/* snake movement */
		function snakeMove(snake) {
			switch (snake.direction) {
			case 'up':
				/* when the up arrow key is pressed */
				snake.y -= snake.size; /* moves player in upward direction based on current size */
				break;
			case 'down':
				/* when the down arrow key is pressed */
				snake.y += snake.size; /* moves player in downward direction based on current size */
				break;
			case 'left':
				/* when the left arrow key is pressed */
				snake.x -= snake.size; /* moves player in leftward direction based on current size */
				break;
			case 'right':
				/* when the right arrow key is pressed */
				snake.x += snake.size; /* moves player in rightward direction based on current size */
				break;
			}
			snake.checkCollision(); /* collision detection */
			checkGrowth(snake, 1); /* growth detection */
			snake.sections.push(snake.x + ',' + snake.y); /* array tracks segements of player via turn points */
		};
		/* draws all segments of the snake */
		function snakeDraw(snake) {
			for (var i = 0; i < snake.sections.length; i++) {
				snake.drawSection(snake.sections[i].split(',')); /* concatenation of player sections are drawn around current turn points */
			}
		};
		/* snake intitial values */
		function snakeInit(snake) {
			snake.sections = []; /* array holds segements of the player */
			snake.direction = 'left'; /* starting direction initialized to left */
			snake.x = canvas.width / 2; /* starting xcoordinate for the player */
			snake.y = canvas.height / 2; /* starting ycoordinate for the player */
			for (var i = snake.x + (5 * snake.size); i >= snake.x; i -= snake.size) { /* array tracks segements of player via turn points */
				snake.sections.push(i + ',' + snake.y);
			}
		};
      /* collision checks */
		function snakeIsCollision(snake, x, y) {
			if (x < snake.size / 2 || /* if player collides with itself horizontally */
				x > canvas.width || /* if player collides with canvas horizontally */
				y < snake.size / 2 || /* if player collides with itself vertically */
				y > canvas.height || /* if player collides with canvas vertically */
				snake.sections.indexOf(x + ',' + y) >= 0) {
				return true; /* a collision has happened */
			}
		};
    function getCol(matrix, col){
       var column = [];
       for(var i=0; i<matrix.length; i++){
          column.push(matrix[i][col]);
       }
       return column;
    };
    function checkX(snake) {
      return getCol(food, x).indexOf(snake.x);
    };
    function checkY(snake) {
      return getCol(food, y).indexOf(snake.y);
    };
    function checkFood(snake) {
      if (checkX(snake) > 0 && checkY(snake) > 0 && checkY(snake) == checkX(snake)) {
        return checkX(snake);
      }
      else {
        return 0
      };
    };
		/* food collection, sees if the player has collided with food */
    function checkGrowth(snake) {
			if (checkFood(snake) > 0) { /* if the player head collides with a food */
				game.score++; /* add to score */
				if (game.score % 5 === 0 && game.fps < 60) {
					game.fps++; /* increase the fps when game score increases by 5 points */
				}
				foodSet(checkX(snake)); /* set another food on the game board */
			}
			else {
				snake.sections.shift();
			}
		};
		/* food1 properties */
		food1 = {};
		/* food2 properties */
		food2 = {};
		/* food3 properties */
		food3 = {};
		/* Test */
  	var x = 1
    var y = 2
    var food = [
      ["foodnum", "x", "y"],
      ["food1", '', ''],
      ["food2", '', ''],
      ["food3", '', '']
    ];
		function foodSet(num) {
			food[num][x] = (Math.ceil(Math.random() * 10) * player.size * 4); /* random x-coordinate chosen for the food piece within game board dimensions */
			food[num][y] = (Math.ceil(Math.random() * 10) * player.size * 3); /* random y-coordinate chosen for the food piece within game board dimensions */
		};
		function foodDraw(color, num) {
			while (player.sections.indexOf(food[num][x] + ',' + food[num][y]) >= 0) {
			  foodSet(num);
			}
			game.drawBox(food[num][x], food[num][y], player.size, color);
		};
		/* sets values to change directional key commands */
		var inverseDirection = {
			'up': 'down',
			/* up key press maps to downwards movement */
			'left': 'right',
			/* left key press maps to rightwards movement */
			'right': 'left',
			/* right key press maps to leftwards movement */
			'down': 'up' /* down key press maps to upwards movement */
		};
		/* sets values for directional key commands */
		var keys = {
			up: [38, 75, 87],
			down: [40, 74, 83],
			left: [37, 65, 72],
			right: [39, 68, 76],
			start_game: [13, 32]
		};
		/* value: integer associated with direction key
		   gets the value of directional key being pressed */
		function getKey(value) {
			for (var key in keys) {
				if (keys[key] instanceof Array && keys[key].indexOf(value) >= 0) {
					return key;
				}
			}
			return null;
		}
		/* function(e) checks for an event (a key press) to happen */
		addEventListener("keydown", function (e) {
			var lastKey = getKey(e.keyCode); /* gets value of directional key */
			if (['up', 'down', 'left', 'right'].indexOf(lastKey) >= 0 && lastKey != inverseDirection[player.direction]) { /* if a key is pressed and key direction is not inversed */
				player.direction = lastKey; /* changes player direction to inverse of last key pressed */
			}
			else if (['start_game'].indexOf(lastKey) >= 0 && game.over) { /* waits for a key to be pressed after a game has ended */
				game.start(); /* game state changed to begin */
			}
		}, false);
		/* updates frames (visual display of the game) */
		var requestAnimationFrame = window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame;
		/* loops through the game if game state isnt equal to over */
		function loop() {
			if (game.over === false) {
				context.canvas.height = Math.floor(window.innerHeight / 15) * 15;
				context.canvas.width = Math.floor(context.canvas.height * (4 / 3));
				game.resetCanvas();
				game.drawScore();
				snakeMove(player);
				snakeMove(ai);
				foodDraw('#0FF', 1);
				foodDraw('#F00', 2);
				foodDraw('#00F', 3);
				snakeDraw(player);
				snakeDraw(ai);
				game.drawMessage();
			}
			setTimeout(function () {
				requestAnimationFrame(loop);
			}, 1000 / game.fps);
		}
		requestAnimationFrame(loop);
		/*]]>*/

	</script>
</body>

</html>
